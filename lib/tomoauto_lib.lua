local tomoauto_directory = os.getenv('TOMOAUTOROOT')
package.cpath = package.cpath .. ';' .. tomoauto_directory .. '/lib/?.so;'
package.path  = package.path  .. ';' ..tomoauto_directory .. '/lib/?.lua;'
local MRC_IO_lib = require 'MRC_IO_lib'
local lfs = require 'lfs'

--[[==========================================================================#
#                              Local Functions                                #
#==========================================================================--]]
local tomoauto_lib = {}
--[[==========================================================================#
#                                 display_help                                #
#-----------------------------------------------------------------------------#
# A function that displays the usage and options of tomoAuto                  #
#==========================================================================--]]
function tomoauto_lib.display_help()
   io.write(
   '\nUsage: \n\z
   tomoAuto [OPTIONS] <file> <fidNm>\n\z
   Automates the alignment of tilt series and the reconstruction of\n\z
   these series into 3D tomograms.\n\n\z
   -c, --CTF      \tApplies CTF correction to the aligned stack\n\z
   -d, --defocus  \tUses this as estimated defocus for ctfplotter\n\z
   -g, --GPU      \tUses GPGPU methods to speed up the reconstruction\n\z
   -h, --help     \tPrints this information and exits\n\z
   -i, --iter     \tThe number of SIRT iterations to run [default 30]\n\z
   -l, --config   \tSources a local config file\n\z
   -m, --mode     \tSelect which mode you want to operate\n\z
   --continued:   \tavailable modes (erase, align, reconstruct).\n\z  
   -p, --procnum  \tUses <int> processors to speed up tilt\n\z
   -s, --SIRT     \tUse SIRT to reconstruct [default WBP]\n\z
   -t, --tomo3d   \tUse the TOMO3D to compute reconstruction\n\z
   -z, --thickness\tCreate a tomogram with <int> thickness\n'
   )
   return true
end
--[[==========================================================================#
#                               check_free_space                              #
#-----------------------------------------------------------------------------#
# A function to check that there is enough free space to successfully run     #
# some of the more data heavy IMOD routines                                   #
#==========================================================================--]]
function tomoauto_lib.check_free_space()
   local file = io.popen(
      string.format(
         'df -h %s',
         lfs.currentdir()
         ),
         'r'
      )
   local contents = file:read('*a')
	file:close()
   local space = tonumber(string.match(contents, '(%d+)%%'))
   if space <= 98 then
      return true
   else
      error(string.format(
            '\nError: Disk usage in %s is above 98%%.\n',
            Directory
         ), 0
      )
   end
end
--[[==========================================================================#
#                                   is_file                                   #
#-----------------------------------------------------------------------------#
# A function to check if file exists, since older versions of IMOD have a     #
# funny way of handling exit codes in case of errors.                         #
#-----------------------------------------------------------------------------#
# Arguments: filename = filename to check <string>                            #
#==========================================================================--]]
function tomoauto_lib.is_file(filename)
   local file = io.open(filename, 'r')
   if file ~= nil then
      io.close(file)
      return true
   else
      error(
         string.format(
            '\nError: %s was not produced or found.\n\n',
            filename
         ), 0
      )
   end
end
--[[==========================================================================#
#                              scale_RAPTOR_model                             #
#-----------------------------------------------------------------------------#
# A function that fixes the fiducial model generated by RAPTOR in how its     #
# drawn and scaled.                                                           #
#-----------------------------------------------------------------------------#
# Arguments: input_filename  = RAPTOR generated fid model <string>            #
#            header          = Image stack header <table>                     #
#            output_filename = Output file <string>                           #
#==========================================================================--]]
function tomoauto_lib.scale_RAPTOR_model(
   input_filename,
   header,
   output_filename
)
   local input_file  = assert(io.open(input_filename, 'r'))
   local output_file = assert(io.open(output_filename, 'w'))

   local refcurscale_string = string.format(
      'refcurscale %5.3f %5.3f %5.3f',
      header.xlen / header.mx,
      header.ylen / header.my,
      header.zlen / header.mz
   )

   for line in input_file:lines('*l') do
      line = string.gsub(
         line,
         'drawmode%s+%d+',
         'drawmode\t1\n\z
         symbol\t\t0\n\z
         symsize\t\t7'
      )
      line = string.gsub(
         line,
         'symbol%s+circle',
         refcurscale_string
      )
      line = string.gsub(line, '^size%s+%d+', '')
      output_file:write(line,'\n')
   end
   input_file:close()
   output_file:close()
end
--[[==========================================================================#
#                               check_alignment                               #
#-----------------------------------------------------------------------------#
# A function that checks the final alignment to make sure that too many high  #
# tilt sections were not cut by newstack or RAPTOR. If more than 10% of the   #
# original sections are missing, we abort the reconstruction                  #
#-----------------------------------------------------------------------------#
# Arguments: input_filename: Aligned Image Stack filename  <string>           #
#            original_nz:    Number of original sections <integer>            #
#==========================================================================--]]
function tomoauto_lib.check_alignment(input_filename, original_nz)
   local header = MRC_IO_lib.get_header(input_filename)
   local aligned_nz = header.nz
   header = nil
   local cut_sections = original_nz - aligned_nz
   if (aligned_nz / original_nz) >= 0.9 then
      return true
   else
      error('\nError: RAPTOR has cut too many sections.\n\n',0)
   end
end
--[[==========================================================================#
#                                  write_log                                  #
#-----------------------------------------------------------------------------#
#  A fuction that writes the tomoauto log file                                #
#-----------------------------------------------------------------------------#
# Arguments: input_filename: image filename <string>                          #
#==========================================================================--]]
function tomoauto_lib.write_log(input_filename)
   local logfile = assert(io.open('tomoauto_IMOD.log', 'w'))

   local ccderaser_logfile = io.open('ccderaser.log', 'r')
   if ccderaser_logfile then
      local ccderaser_log = ccderaser_logfile:read('*a')
      ccderaser_logfile:close();
      logfile:write(ccderaser_log, '\n')
   end

   local tiltxcorr_logfile = io.open('tiltxcorr.log', 'r')
   if tiltxcorr_logfile then
      local tiltxcorr_log = tiltxcorr_logfile:read('*a')
      tiltxcorr_logfile:close();
      logfile:write(tiltxcorr_log, '\n')
   end

   local xftoxg_logfile = io.open('xftoxg.log', 'r')
   if xftoxg_logfile then
      local xftoxg_log = xftoxg_logfile:read('*a')
      xftoxg_logfile:close()
      logfile:write(xftoxg_log, '\n')
   end

   local prenewstack_logfile = io.open('prenewstack.log', 'r')
   if prenewstack_logfile then
      local prenewstack_log = prenewstack_logfile:read('*a')
      prenewstack_logfile:close()
      logfile:write(prenewstack_log, '\n')
   end

   local RAPTOR_logfile = io.open(
      string.format(
         'RAPTOR/align/%s_RAPTOR.log',
         filename
      ),
      'r'
   )
   if RAPTOR_logfile then
      local RAPTOR_log = RAPTOR_logfile:read('*a')
      RAPTOR_logfile:close()
      logfile:write(RAPTOR_log, '\n')
   end

   local tiltalign_logfile = io.open('tiltalign.log', 'r')
   if tiltalign_logfile then
      local tiltalign_log = tiltalign_logfile:read('*a')
      tiltalign_logfile:close()
      logfile:write(tiltalign_log, '\n')
   end

   local xfproduct_logfile = io.open('xfproduct.com', 'r')
   if xfproduct_logfile then
      local xfproduct_log = xfproduct_logfile:read('*a')
      xfproduct_logfile:close()
      logfile:write(xfproduct_log, '\n')
   end

   local newstack_logfile = io.open('newstack.com', 'r')
   if newstack_logfile then
      local newstack_log = newstack_logfile:read('*a')
      newstack_logfile:close()
      logfile:write(newstack_log, '\n')
   end

   local ctfplotter_logfile = io.open('ctfplotter.log', 'r')
   if ctfplotter_logfile then
      local ctfplotter_log = ctfplotter_logfile:read('*a')
      ctfplotter_logfile:close()
      logfile:write(ctfplotter_log, '\n')
   end

   local ctfphaseflip_logfile = io.open('ctfphaseflip.log', 'r')
   if ctfphaseflip_logfile then
      local ctfphaseflip_log = ctfphaseflip_logfile:read('*a')
      ctfphaseflip_logfile:close()
      logfile:write(ctfphaseflip_log, '\n')
   end

   local gold_ccderaser_logfile = io.open('gold_ccderaser.log', 'r')
   if gold_ccderaser_logfile then
      local gold_ccderaser_log = gold_ccderaser_logfile:read('*a')
      gold_ccderaser_logfile:close()
      logfile:write(gold_ccderaser_log, '\n')
   end

   local tilt_logfile = io.open('tilt.log', 'r')
   if tilt_logfile then
      local tilt_log = tilt_logfile:read('*a')
      tilt_logfile:close()
      logfile:write(tilt_log, '\n')
   end

   logfile:close()
end

--[[===========================================================================#
#                              modify_ctfplotter                               #
#------------------------------------------------------------------------------#
# A function that fixes the ctfplotter.com file so that it can be checked.     #
#===========================================================================--]]
function tomoauto_lib.modify_ctfplotter()
   local file = io.open('ctfplotter.com', 'r')
   local temp = io.open('tmp.com', 'w')
   for line in file:lines('*l') do
      line = string.gsub(line, 'SaveAndExit', '#SaveAndExit')
      line = string.gsub(line, 'AutoFitRangeAndStep', '#AutoFitRangeAndStep')
      temp:write(line, '\n')
   end
   file:close()
   temp:close()
   local success, exit, signal = os.execute('mv tmp.com ctfplotter.com')
   if not success or signal ~= 0 then
      error('\nError: mv tmp.com ctfplotter.com failed.\n\n', 0)
   else
      return true
   end
end
--[[===========================================================================#
#                                median_filter                                 #
#------------------------------------------------------------------------------#
# A command that imitates a median filter of N slices.                         #
#------------------------------------------------------------------------------#
# Arguments: input_filename: image filename <string>                           #
#            filter_size:    filter size <integer>                             #
#===========================================================================--]]
function tomoauto_lib.median_filter(input_filename, filter_size)
   
   if not input_filename then
      error('\nError: No input file entered.\n\n', 0)
   elseif not filter_size then
      error('\nError: No filter size entered.\n\n', 0)
   end
   local median_filtered_filename = input_filename .. filter_size

   local header = MRC_IO_lib.get_header(input_filename)
   local nz = header.nz
   header = nil

   local file_list = assert(io.open('filelist.txt', 'w'))
   file_list:write(nz, '\n')

   filter_size = tonumber(filter_size)
   local is_even = (filter_size % 2 == 0) and true or false

   for i = 1, nz do
      average_filename = string.format(
         '%s.avg_%04d',
         input_filename,
         i
      )
      file_list:write(string.format(
         '%s\n0\n',
         average_filename
      ))
      if is_even then
         if i < nz / 2 then
            left_index  = i - ((filter_size / 2) - 1)
            right_index = i +  (filter_size / 2)
            if left_index < 1 then
               local shift = 1 - left_index
               left_index  = left_index  + shift
               right_index = right_index + shift
            end
         else
            left_index  = i -  (filter_size / 2)
            right_index = i + ((filter_size / 2) - 1)
            if right_index > nz then
               local shift = right_index - nz
               left_index  = left_index  - shift
               right_index = right_index - shift
            end
         end
      else
         left_index  = i - math.floor(filter_size / 2)
         right_index = i + math.floor(filter_size / 2)
         if left_index < 1 then
            local shift = 1 - left_index
            left_index  = left_index  + shift
            right_index = right_index + shift
         elseif right_index > nz then
            local shift = right_index - nz
            left_index  = left_index  - shift
            right_index = right_index - shift
         end
      end
      local success, exit, signal = os.execute(
         string.format(
            'xyzproj -z "%d %d" -axis Y %s %s &> /dev/null',
            left_index,
            right_index,
            input_filename,
            average_filename
         )
      )
      if not success or signal ~= 0 then
         os.execute('rm filelist.txt')
         error('\nError: median_filter xyzproj failed.\n\n', 0)
      end
      tomoauto_lib.is_file(average_filename)
   end
   file_list:close()
   file_list = nil
   success, exit, signal = os.execute(
      string.format(
         'newstack -filei filelist.txt %s &> /dev/null',
         median_filtered_filename
      )
   )
   if not success or signal ~= 0 then
      pcall(os.execute,
         string.format(
            'rm filelist.txt %s %s.avg_*', 
            median_filtered_filename,
            input_filename
         )
      )
      error('\nError: median_filter newstack failed.\n\n', 0)
   end
   tomoauto_lib.is_file(median_filtered_filename)
   success, exit, signal = os.execute(
      string.format(
         'rm -f filelist.txt %s.avg_*',
         input_filename
      )
   )
   if not success or signal ~= 0 then
      error('\nError: median_filter cleanup failed.\n\n', 0)
   end
end

return tomoauto_lib
